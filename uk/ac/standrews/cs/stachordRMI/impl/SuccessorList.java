/*
 *  StAChord Library
 *  Copyright (C) 2004-2008 Distributed Systems Architecture Research Group
 *  http://asa.cs.st-andrews.ac.uk/
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/* Generated by Together */

package uk.ac.standrews.cs.stachordRMI.impl;

import java.util.ArrayList;
import java.util.List;

import uk.ac.standrews.cs.nds.p2p.interfaces.IKey;
import uk.ac.standrews.cs.stachordRMI.events.ChordEventFactory;
import uk.ac.standrews.cs.stachordRMI.events.Constants;
import uk.ac.standrews.cs.stachordRMI.impl.exceptions.NoReachableNodeException;
import uk.ac.standrews.cs.stachordRMI.interfaces.IChordRemote;

public class SuccessorList {

	public static int MAX_SUCCESSOR_LIST_SIZE = 5;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////

	private final ChordNodeImpl local_node;
	private List<IChordRemote> successor_list;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////

	public SuccessorList(ChordNodeImpl local_node) {

		this.local_node = local_node;
		successor_list = new ArrayList<IChordRemote>();
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////

	/**
	 * Searches the successor list for a working node.
	 * 
	 * @return the first working node in the SuccessorList
	 * @throws NoReachableNodeException if no working node is found
	 */
	protected IChordRemote findFirstWorkingNode() throws NoReachableNodeException {

		for (IChordRemote next : successor_list) {
			try {
				next.isAlive();
				return next;
			}
			catch (Exception e) {
				local_node.recordEvent(Constants.SUCCESSOR_ACCESS_EVENT, Constants.FIELD_ACCESS_FAILED);
			}
		}
		throw new NoReachableNodeException();
	}

	/**
	 * @return the successor list
	 */
	protected List<IChordRemote> getList() {
		return successor_list;
	}

	/**
	 * Constructs a new successor list which consists of this node's successor
	 * followed by the first (MAX_SIZE-1) elements of the successor's successor
	 * list.
	 */
	protected boolean refreshList() {

		List<IChordRemote> removed = null;
		List<IChordRemote> new_list = null;

		// This is a new ring or we have collapsed back to a single node.
		if (successor_list.size() > 0) {

			// The successor list is not empty.
			removed = successor_list;
			new_list = new ArrayList<IChordRemote>();
		}

		return generateSuccessorListChangeEvent(null, removed, new_list);
	}

	/**
	 * Constructs a new successor list which consists of this node's successor
	 * followed by the first (MAX_SIZE-1) elements of the successor's successor
	 * list.
	 */
	protected boolean refreshList(List<IChordRemote> successor_list_of_successor) {

		IChordRemote successor = local_node.getSuccessor();

		List<IChordRemote> added = null;
		List<IChordRemote> removed = null;
		List<IChordRemote> new_list = null;

		new_list = new ArrayList<IChordRemote>();

		int numElements = Math.min(MAX_SUCCESSOR_LIST_SIZE - 1, successor_list_of_successor.size());

		// Check for the element of the successor list being this node, as will
		// happen with a small number of nodes in the ring. If this node is
		// found in the received successor list then that element and all
		// elements following it are discarded.

		for (int i = 0; i < numElements; i++) {

			IChordRemote node = successor_list_of_successor.get(i);

			if (node.getKey().equals(local_node.getKey())) {
				break;
			}

			new_list.add(node);
		}

		new_list.add(0, successor);

		added =   addedNodes(successor_list, new_list);
		removed = removedNodes(successor_list, new_list);

		return generateSuccessorListChangeEvent(added, removed, new_list);
	}

	private boolean generateSuccessorListChangeEvent(List<IChordRemote> added, List<IChordRemote> removed, List<IChordRemote> new_list) {

		if (added != null || removed != null) {

			// for the autonomic management we check if successor list is
			// different and monitor a state change of the successor list

			successor_list = new_list;

			KeyRange keyRange = null;
			IChordRemote pred = local_node.getPredecessor();

			/*
			 * This node's predecessor may be null.
			 */
			if (pred != null) {
				IKey pred_key = pred.getKey();
				keyRange = new KeyRange(pred_key, local_node.getKey(), false);
			}

			/*
			 * If pred is null then we cannot work out the key range for the
			 * local node. Here we generate the event regardless of whether or
			 * not we know the local key range.
			 */
			local_node.generateEvent(ChordEventFactory.makeSuccessorListChangeEvent(successor_list, keyRange, new_list, added, removed));

			return true;
		}
		else return false;
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////

	/**
	 * Computes the set of nodes that are in the successor list received from
	 * this node's successor and which are not in this node's current successor
	 * list.
	 * 
	 * @param current_list the entries (in ring order) in this node's current successor list
	 * @param new_list the successor list entries (in ring order) received from this node's successor, which does not contain this node's successor,
	 * assuming that this node's successor has been added to the start of the list.
	 */
	private List<IChordRemote> addedNodes(List<IChordRemote> current_list, List<IChordRemote> new_list) {

		// For each node in new_list, if the node is not in currentList, add the node to added.
		List<IChordRemote> added = null;

		for (IChordRemote node : new_list)
			if (!containsNode(current_list, node)) {

				if (added == null) {
					added = new ArrayList<IChordRemote>();
				}
				added.add(node);
			}

		return added;
	}

	/**
	 * Computes the set of nodes that are in this node's current successor list
	 * and which are not in the successor list received form this node's
	 * successor.
	 * 
	 * @param current_list the entries (in ring order) in this node's current successor list
	 * @param new_list the successor list entries (in ring order) received from this node's successor, which does not contain this node's successor,
	 * assuming that this node's successor has been added to the start of the list.
	 */
	private List<IChordRemote> removedNodes(List<IChordRemote> current_list, List<IChordRemote> new_list) {

		// For each node in currentList, if the node is not in newList, add the node to removed.

		List<IChordRemote> removed = null;

		for (IChordRemote node : current_list)
			if (!containsNode(new_list, node)) {

				if (removed == null) {
					removed = new ArrayList<IChordRemote>();
				}
				removed.add(node);
			}

		return removed;
	}

	private boolean containsNode(List<IChordRemote> list, IChordRemote node) {

		for (IChordRemote list_element : list)
			if (list_element.getKey().equals(node.getKey())) return true;

		return false;
	}
}