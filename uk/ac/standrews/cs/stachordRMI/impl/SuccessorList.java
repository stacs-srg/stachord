/*
 *  StAChord Library
 *  Copyright (C) 2004-2008 Distributed Systems Architecture Research Group
 *  http://asa.cs.st-andrews.ac.uk/
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/* Generated by Together */

package uk.ac.standrews.cs.stachordRMI.impl;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.List;

import uk.ac.standrews.cs.nds.p2p.interfaces.IKey;
import uk.ac.standrews.cs.stachordRMI.impl.exceptions.NoReachableNodeException;
import uk.ac.standrews.cs.stachordRMI.interfaces.IChordRemote;
import uk.ac.standrews.cs.stachordRMI.interfaces.IChordRemoteReference;

public class SuccessorList {

	public static int MAX_SUCCESSOR_LIST_SIZE = 5;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////

	private final ChordNodeImpl local_node;
	private ArrayList<IChordRemoteReference> successor_list;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////

	public SuccessorList(ChordNodeImpl local_node) {

		this.local_node = local_node;
		successor_list = new ArrayList<IChordRemoteReference>();
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////

	/**
	 * Searches the successor list for a working node.
	 * 
	 * @return the first working node in the SuccessorList
	 * @throws NoReachableNodeException if no working node is found
	 */
	protected IChordRemoteReference findFirstWorkingNode() throws NoReachableNodeException {

		for (IChordRemoteReference next : successor_list) {
			try {
				next.getRemote().isAlive();
				return next;
			}
			catch (Exception e) {
				// local_node.recordEvent(Constants.SUCCESSOR_ACCESS_EVENT, Constants.FIELD_ACCESS_FAILED);
			}
		}
		throw new NoReachableNodeException();
	}

	/**
	 * @return the successor list
	 */
	protected ArrayList<IChordRemoteReference> getList() {
		return successor_list;
	}

	/**
	 * Constructs a new successor list which consists of this node's successor
	 * followed by the first (MAX_SIZE-1) elements of the successor's successor
	 * list.
	 */
	protected boolean refreshList() {

		ArrayList<IChordRemoteReference> removed = null;
		ArrayList<IChordRemoteReference> new_list = null;

		// This is a new ring or we have collapsed back to a single node.
		if (successor_list.size() > 0) {

			// The successor list is not empty.
			removed = successor_list;
			new_list = new ArrayList<IChordRemoteReference>();
		}

		return generateSuccessorListChangeEvent(null, removed, new_list);
	}

	/**
	 * Constructs a new successor list which consists of this node's successor
	 * followed by the first (MAX_SIZE-1) elements of the successor's successor
	 * list.
	 */
	protected boolean refreshList(List<IChordRemoteReference> successor_list_of_successor) {

		IChordRemoteReference successor = local_node.getSuccessor();

		ArrayList<IChordRemoteReference> added = null;
		ArrayList<IChordRemoteReference> removed = null;
		ArrayList<IChordRemoteReference> new_list = null;

		new_list = new ArrayList<IChordRemoteReference>();

		int numElements = Math.min(MAX_SUCCESSOR_LIST_SIZE - 1, successor_list_of_successor.size());

		// Check for the element of the successor list being this node, as will
		// happen with a small number of nodes in the ring. If this node is
		// found in the received successor list then that element and all
		// elements following it are discarded.

		for (int i = 0; i < numElements; i++) {

			IChordRemoteReference node = successor_list_of_successor.get(i);

			if (node.getKey().equals(local_node.getKey())) {
				break;
			}

			new_list.add(node);
		}

		new_list.add(0, successor);

		added =   addedNodes(successor_list, new_list);
		removed = removedNodes(successor_list, new_list);

		return generateSuccessorListChangeEvent(added, removed, new_list);
	}

	private boolean generateSuccessorListChangeEvent(ArrayList<IChordRemoteReference> added, ArrayList<IChordRemoteReference> removed, ArrayList<IChordRemoteReference> new_list) {

		if (added != null || removed != null) {

			// for the autonomic management we check if successor list is
			// different and monitor a state change of the successor list

			successor_list = new_list;

			KeyRange keyRange = null;
			IChordRemoteReference pred = local_node.getPredecessor();

			/*
			 * This node's predecessor may be null.
			 */
			if (pred != null) {
				IKey pred_key;
				pred_key = pred.getKey();
				keyRange = new KeyRange(pred_key, local_node.getKey(), false);
				
			}

			return true;
		}
		else return false;
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////

	/**
	 * Computes the set of nodes that are in the successor list received from
	 * this node's successor and which are not in this node's current successor
	 * list.
	 * 
	 * @param current_list the entries (in ring order) in this node's current successor list
	 * @param new_list the successor list entries (in ring order) received from this node's successor, which does not contain this node's successor,
	 * assuming that this node's successor has been added to the start of the list.
	 */
	private ArrayList<IChordRemoteReference> addedNodes(List<IChordRemoteReference> current_list, List<IChordRemoteReference> new_list) {

		// For each node in new_list, if the node is not in currentList, add the node to added.
		ArrayList<IChordRemoteReference> added = null;

		for (IChordRemoteReference node : new_list)
			if (!containsNode(current_list, node)) {

				if (added == null) {
					added = new ArrayList<IChordRemoteReference>();
				}
				added.add(node);
			}

		return added;
	}

	/**
	 * Computes the set of nodes that are in this node's current successor list
	 * and which are not in the successor list received form this node's
	 * successor.
	 * 
	 * @param current_list the entries (in ring order) in this node's current successor list
	 * @param new_list the successor list entries (in ring order) received from this node's successor, which does not contain this node's successor,
	 * assuming that this node's successor has been added to the start of the list.
	 */
	private ArrayList<IChordRemoteReference> removedNodes(List<IChordRemoteReference> current_list, List<IChordRemoteReference> new_list) {

		// For each node in currentList, if the node is not in newList, add the node to removed.

		ArrayList<IChordRemoteReference> removed = null;

		for (IChordRemoteReference node : current_list)
			if (!containsNode(new_list, node)) {

				if (removed == null) {
					removed = new ArrayList<IChordRemoteReference>();
				}
				removed.add(node);
			}

		return removed;
	}

	private boolean containsNode(List<IChordRemoteReference> list, IChordRemoteReference node) {

		for (IChordRemoteReference list_element : list)
			if (list_element.getKey().equals(node.getKey())) return true;

		return false;
	}
	
	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append( "Successors: " );
		if( successor_list.isEmpty() ) {
			sb.append( "empty" );
			
		} else {
			for( IChordRemoteReference ref : successor_list ) {
				sb.append( ref.getKey() + "," );
			}
			sb.deleteCharAt( sb.length() - 1 );
		}
		return sb.toString();
	}
}